<html>

<head>
    <title>Construct Flipbook</title>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-geo@1"></script>
    <script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>
    <script src="https://unpkg.com/d3-geo-polygon@1"></script>
    <script src="https://d3js.org/topojson.v2.min.js"></script>
    <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-color@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-interpolate@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-scale-chromatic@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-ease@3"></script>
    <script src="projections.js"></script> <!-- Map Projection Rotation -->

</head>

<style>
    body {
        background-color: blue;
    }
</style>

<body>

    <h1>This is the Construct a Flipbook Page.</h1>

    <div id="parent">
        <div id="container" style="width: 700; height:700;">
        </div>
        <div id="container-hidden" style="width: 500; height:700;">
            <!-- <canvas id="polyCanvas"></canvas>
            <canvas id="testCanvas"></canvas> -->
        </div>
    </div>


</body>

<script>

    console.log(projectionOptions);

    var abortion = d3.map();
    var width;

    function clipProjectionByLat(projection, minLat, maxLat) {

        var maxLon = 180 - 0.01; // bug where if 180 breaks the clipping
        var minLon = -180

        return projection
            .preclip(d3.geoClipPolygon({
                type: "Polygon",
                coordinates: [[[minLon, minLat], [minLon, maxLat], [maxLon, maxLat], [maxLon, minLat], [minLon, minLat]]]
            }))
        //.fitWidth(canvasWidth, outline);


    }


    function interpolateProjection(raw0, raw1) {
        // THIS FUNCTION TAKEN DIRECTLY FROM MIKE BOSTOCK'S ORTHOGRAPHIC TO EQUIRECTANGULAR BLOCK
        // https://observablehq.com/@d3/orthographic-to-equirectangular
        const mutate = d3.geoProjectionMutator(t => (x, y) => {
            const [x0, y0] = raw0(x, y), [x1, y1] = raw1(x, y);
            return [x0 + t * (x1 - x0), y0 + t * (y1 - y0)];
        });
        let t = 0;
        return Object.assign(mutate(t), {
            alpha(_) {
                return arguments.length ? mutate(t = +_) : t;
            }
        });
    }

    d3.queue()
        .defer(d3.json, "/data/countries-110m.json")
        .defer(d3.csv, "/data/abortion-access_clean.csv", function (d) { abortion.set(d.id, { id: d.id, value: +d.value }); })
        .await(ready);
    function ready(error, countries110m) {

        if (error) throw error;

        // Define Map Boundaries 
        let countries = topojson.feature(countries110m, countries110m.objects.countries);
        let countrymesh = topojson.mesh(countries110m, countries110m.objects.countries, (a, b) => a !== b)
        let graticule = d3.geoGraticule10()
        let outline = ({ type: "Sphere" })

        function constructCanvas(containerId) {

            // Select Container & Get Height and Width 
            var container = d3.select(containerId)
            width = container.node().clientWidth; // defined globally; 
            var height = container.node().clientHeight;

            var topCanvas = d3.select(containerId).append('canvas').attr('class', 'top');
            var middleCanvas = d3.select(containerId).append('canvas').attr('class', 'middle');
            var bottomCanvas = d3.select(containerId).append('canvas').attr('class', 'bottom');

            var canvases = [topCanvas, middleCanvas, bottomCanvas]

            canvases.forEach(function (element) {
                element.attr('width', width);
                element.attr('style', 'margin: 3px')
            });

            // BRING BACK 
            //return [topCanvas.node(), middleCanvas.node(), bottomCanvas.node()]

            return [topCanvas, middleCanvas, bottomCanvas]
        }

        function sizeScaleSection(canvas, unclippedProjection, minLat, maxLat) {
            // Given a canvas, unclipped projection (eg, d3.geoMercator()), and minLat and maxLat, set the height of the section and return the path with the correct global scale
            // what if all this should return are the paths 
            var context = canvas.getContext('2d');
            var canvasWidth = canvas.width;
            var outline = ({ type: "Sphere" });

            var projection = clipProjectionByLat(unclippedProjection, minLat, maxLat);

            // Find out the global scale for a given projection at that size
            var globalScale = unclippedProjection.fitWidth(canvasWidth, outline).scale();

            // Find the height of a projection by taking the minimum and max values 
            var sectionHeight = d3.geoPath(projection).bounds(outline)[1][1] - d3.geoPath(projection).bounds(outline)[0][1]

            canvas.height = sectionHeight // KEEP OR NOT KEEP? OR RETURN SEPARATE 

            // Apply this scale to the clipped projection
            var path = d3.geoPath(projection.scale(globalScale), context);


            return path;
        }


        function createSection(canvas, path, countries) {
            var context = canvas.getContext('2d');

            context.save();
            context.beginPath(), path(graticule), context.strokeStyle = "#ccc", context.stroke();
            //context.beginPath(), path(land), context.fillStyle = "#000", context.fill();
            context.beginPath(), path(countries), context.fillStyle = "#000", context.fill();
            context.beginPath(), path(countrymesh), context.strokeStyle = "#fff", context.stroke();
            context.restore();

        }

        var currentPath;
        var currentT;

        function transitionSection(canvas, projection, minLat, maxLat, duration) {

            const ease = d3.easeQuadIn;
            var context = canvas.getContext('2d');

            // var scaledSection = sizeScaleSection(canvas, unclippedProjection, minLat, maxLat);
            // var path = scaledSection[0]
            // var projection = scaledSection[1]
            // var globalScale = scaledSection[2]

            // Need a way to get the global scale at the beginning and the global scale at the end 
            var path;
            timer = d3.timer((elapsed) => {
                // compute how far through the animation we are (0 to 1)
                const t = Math.min(1, ease(elapsed / duration));

                path = sizeScaleSection(canvas, projection.alpha(t), minLat, maxLat);
                context.clearRect(0, 0, width, canvas.height);
                context.beginPath(), context.strokeStyle = "#fff", path(countries), context.stroke();

                // if this animation is over
                if (t === 1) {
                    // stop this timer since we are done animating.
                    // return the path so that it can be used by choropleth
                    //currentPath = sizeScaleSection(canvas, projection.alpha(1), minLat, maxLat);
                    timer.stop();
                }
            });


            // do something


        }


        var canvases = constructCanvas("#container");
        var topCanvas = canvases[0];
        var middleCanvas = canvases[1];
        var bottomCanvas = canvases[2];

        const duration = 1000;

        var rawProjection0 = projectionOptions[Math.floor(Math.random() * projectionOptions.length)].projection;
        var rawProjection1 = projectionOptions[Math.floor(Math.random() * projectionOptions.length)].projection;
        var rawProjection2 = projectionOptions[Math.floor(Math.random() * projectionOptions.length)].projection;

        console.log(rawProjection0);
        console.log(rawProjection1);
        console.log(rawProjection2);

        //var projection = interpolateProjection(rawProjectionOne, rawProjectionTwo);

        var projectionRotations = [
            {
                'top': interpolateProjection(rawProjection0, rawProjection1),
                'middle': interpolateProjection(rawProjection1, rawProjection2),
                'bottom': interpolateProjection(rawProjection2, rawProjection0)
            },

            {
                'top': interpolateProjection(rawProjection1, rawProjection2),
                'middle': interpolateProjection(rawProjection2, rawProjection0),
                'bottom': interpolateProjection(rawProjection0, rawProjection1)
            },

            {
                'top': interpolateProjection(rawProjection2, rawProjection0),
                'middle': interpolateProjection(rawProjection0, rawProjection1),
                'bottom': interpolateProjection(rawProjection1, rawProjection2),
            }

        ]

        function roundOne() {
            transitionSection(topCanvas, projectionRotations[0].top, 30, 85, duration)
            transitionSection(middleCanvas, projectionRotations[0].middle, -30, 30, duration)
            transitionSection(bottomCanvas, projectionRotations[0].bottom, -80, -30, duration)
        };


        function roundTwo() {
            transitionSection(topCanvas, projectionRotations[1].top, 30, 85, duration)
            transitionSection(middleCanvas, projectionRotations[1].middle, -30, 30, duration)
            transitionSection(bottomCanvas, projectionRotations[1].bottom, -80, -30, duration)
        }

        function roundThree() {
            transitionSection(topCanvas, projectionRotations[2].top, 30, 85, duration)
            transitionSection(middleCanvas, projectionRotations[2].middle, -30, 30, duration)
            transitionSection(bottomCanvas, projectionRotations[2].bottom, -80, -30, duration)
        }

        var canvas = topCanvas;
        var context = topCanvas.node().getContext("2d");
        context.clearRect(0, 0, width, canvas.node().height);

        // create the path
        var projection = interpolateProjection(rawProjection0, rawProjection1);
        //var path = d3.geoPath().projection(projection).context(context);

        canvas.call(repeatTop);
        

        function repeat() {
            d3.select(this).transition()
                .tween("nothing", tween)
                .duration(3000)
                //.on("end", repeat);
                .on("end", applyChoropleth)
        }
        

        function repeatTop(){
            d3.select(this).transition()
                .tween("nothing", tween)
                .duration(3000)
                //.on("end", repeat);
                .on("end", function () {
                    applyChoropleth(d3.interpolateBlues)
                })

        }


        

        function applyChoropleth(colorName){
            // CHOROPLETH
            //var projection = d3.geoMercator(); 
            var domain = d3.extent(abortion.values(), function (d) { return d.value });

            var range = colorName
            var color = d3.scaleSequential()
                          .domain(domain)
                          .interpolator(d3.interpolateBlues);
            var minLat = 30;
                var maxLat = 89;
            console.log(range);
            console.log(countries)
            var path = sizeScaleSection(canvas.node(), projection.alpha(1), minLat, maxLat);

            countries.features.forEach(function (d) {
                console.log(d)

                // check that the country id exists in the dataset
                if (typeof (abortion.get(d.id)) != 'undefined') {
                    context.fillStyle = color(abortion.get(d.id).value); // THIS IS THE LINE TO FIX
                    context.beginPath();
                    path(d);
                    context.fill();
                    context.stroke();
                }
                else {
                    context.beginPath(), context.fillStyle = "#f0f0f0", path(d), context.fill();
                }
            });

        }

        function tween() {
            // return interpolator:
            return function (t) {

                // clear the canvas once per frame:
                var minLat = 30;
                var maxLat = 89;

                var path = sizeScaleSection(canvas.node(), projection.alpha(t), minLat, maxLat);
                context.beginPath(), context.strokeStyle = "#fff", path(countries), context.stroke();

                return ""; // return a value to set the "whatever" attribute
            }}


            var topChoro = applyChoropleth()
            var middleChoro = applyChoropleth()
            var bottomChoro = applyChoropleth()


            // function fullCycle() {
            //     roundOne()
            //     d3.timeout(roundTwo, duration);
            //     d3.timeout(roundThree, duration * 2);
            // }

            // d3.interval(fullCycle, duration * 3);


            // path = sizeScaleSection(topCanvas, projectionRotations[0].top, 30, 85);
            // var context = topCanvas.getContext('2d');
            // context.strokeStyle = "#fff";
            // context.lineWidth = 0.3;

            // // CHOROPLETH
            // var domain = d3.extent(abortion.values(), function (d) { return d.value });
            // var range = d3.interpolateBlues
            // var color = d3.scaleSequential(domain, range);
            // console.log(range);
            // console.log(countries)

            // countries.features.forEach(function (d) {
            //     console.log(d)
            //     // check that the country id exists in the dataset
            //     if (typeof (abortion.get(d.id)) != 'undefined') {
            //         context.fillStyle = color(abortion.get(d.id).value);
            //         context.beginPath();
            //         currentP(d);
            //         context.fill();
            //         context.stroke();
            //     }
            //     else {
            //         context.beginPath(), context.fillStyle = "#f0f0f0", path(d), context.fill();
            //     }
            // });



            // Apply the Choropleth, etc. here?

            // d3.setTimeout(() => {

            // }, timeout);

            // // Second Rotation


            // // Third Rotation

        }



</script>



</html>